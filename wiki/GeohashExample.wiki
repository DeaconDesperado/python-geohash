#summary geohash reference
#labels Phase-Implementation,Featured,example
= geohash module =

== Basic geohash routines ==
geohash module provides geohash routines.
 * geohash.*encode*(_latitude, longitude`[`, precision`]`_)
 Create a geohash string from two floating numbers of latitude and longitude. Precision defaults to 12, which is usually sufficient for most cases.
{{{
>>> import geohash
>>> print 'Geohash for 42.6, -5.6:', geohash.encode(42.6, -5.6)
Geohash for 42.6, -5.6: ezs42e44yx96
>>> print 'Geohash for 42.6, -5.6:', geohash.encode(42.6, -5.6, precision=5)
Geohash for 42.6, -5.6: ezs42
}}}

 * geohash.*decode*(_hashcode`[`, delta`]`_)
{{{
>>> print 'Coordinate for Geohash ezs42:', geohash.decode('ezs42')
Coordinate for Geohash ezs42: (42.60498046875, -5.60302734375)
>>> print 'Exact coordinate for Geohash ezs42:\n', geohash.decode_exactly('ezs42')
Exact coordinate for Geohash ezs42:
(42.60498046875, -5.60302734375, 0.02197265625, 0.02197265625)
}}}

 * geohash.*bbox*(_hashcode_)
 You can get bounding box like this:
{{{
>>> geohash.bbox('ezs42')
{'s': 42.5830078125, 'e': -5.5810546875, 'w': -5.625, 'n': 42.626953125}
}}}

 * geohash.*neighbors*(_hashcode_)
 When you want to get neighbor codes of a specific code, use neighbors(). expand() includes the center code together with neighbors().
{{{
>>> geohash.neighbors('ezs42')
['ezefr', 'ezs43', 'ezefx', 'ezs48', 'ezs49', 'ezefp', 'ezs40', 'ezs41']
>>> geohash.expand('ezs42')
['ezefr', 'ezs43', 'ezefx', 'ezs48', 'ezs49', 'ezefp', 'ezs40', 'ezs41', 'ezs42']
}}}

 http://python-geohash.googlecode.com/svn/wiki/neighbors.png

== Uint64 routines ==
For most of our use case, 64bit representation is sufficient and it can be calculated *very fast* in most computers. So please do consider using 64bit integer representation instead of geohash. geohash and 64bit representations can be converted from each other.

geohash module also provide a set of uint64 (64 bit unsigned integer) representation routines.

 * geohash.*encode_uint64*(_latitude, longitude_)
 This function encodes geometric coordinates of two doubles into one unsinged 64 bit integer.

 * geohash.*decode_uint64*(_ui64_)
 This function decode one 64 bit unsigned integer into two doubles.

 * geohash.*expand_uint64*(_ui64`[`, precision`]`_)
 This function returns integer ranges that cover the expanded area of specified ui64, unsigned 64 bit integer. The ranges are list of two element tuples, which means lower boundary and higher boundary. If the element has None, then you don't have to check that boundary.
 precision is the number of bits. Value must be in 0 to 64, because there we have 64 bits.

=== Uint64 examples ===
With geohash, we usually need a string which length is 8 or 9, 10 chars. That means we need at most 50bits. 32bit is not sufficient but 64bit is OK. So the two can be converted each other, while you use a geohash of less than 13 chars.

{{{
>>> import geohash
>>> hex(geohash.encode_uint64(0.0, 0.0))
'0xc000000000000000'
>>> geohash.encode(0.0, 0.0)
's00000000000'
}}}

Geohash is a good representation because it makes easy to query a small area with a single data key. However, it use a string prefix match. And string prefix match could be calculated in integer range comparison with good control over the precision.

{{{
>>> import geohash
>>> shift = 64-precision
>>> lo = geohash.encode_uint64(0.0, 0.0) & (0xFFFFFFFFFFFFFFFF<<shift)
>>> hi = lo + (1<<shift)
>>> db.execute("SELECT * FROM samples WHERE geoint>=? AND geoint<?", (lo, hi))
}}}

With uint64, you can get the ranges by expand_uint64.
{{{
>>> import geohash
>>> ui = geohash.encode_uint64(0,0)
>>> geohash.expand_uint64(ui, 45)
[(4611686018426863616, 4611686018427387904), 
 (7686143364045471744, 7686143364045996032), 
 (7686143364046520320, 7686143364047044608), 
 (10760600709663555584, 10760600709664604160), 
 (13835058055282163712, 13835058055284260864)]
>>> 
>>> conds = []
>>> param = []
>>> for hilo from geohash.expand_uint64(ui, 45):
>>>   if hilo[0] and hilo[1]:
>>>     conds.append("(geoint>=? AND geoint<?)")
>>>     param.append(hilo[0])
>>>     param.append(hilo[1])
>>>   elif hilo[0]:
>>>     conds.append("geoint>=?")
>>>     param.append(hilo[0])
>>>   elif hilo[1]:
>>>     conds.append("geoint<?")
>>>     param.append(hilo[1])
>>> 
>>> if conds:
>>>     db.execute("SELECT * FROM samples WHERE " + " OR ".join(conds), param)
>>> else:
>>>     db.execute("SELECT * FROM samples")
}}}