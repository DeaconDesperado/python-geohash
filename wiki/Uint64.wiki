#summary uint64, another representation of geo coordinates.
#labels Featured

= Introduction =
For most of our use case, 64bit representation is sufficient and it can be calculated *very fast* in most computers. So please do consider using 64bit integer representation instead of geohash. geohash and 64bit representations can be converted from each other.

= Details =
With geohash, we usually need a string which length is 8 or 9, 10 chars. That means we need at most 50bits. 32bit is not sufficient but 64bit is OK. So the two can be converted each other, while you use a geohash of less than 13 chars.

{{{
>>> import geohash
>>> hex(geohash.encode_uint64(0.0, 0.0))
'0xc000000000000000'
>>> geohash.encode(0.0, 0.0)
's00000000000'
}}}

Geohash is a good representation because it makes easy to query a small area with a single data key. However, it use a string prefix match. And string prefix match could be calculated in integer range comparison with good control over the precision.

{{{
>>> import geohash
>>> shift = 64-precision
>>> lo = geohash.encode_uint64(0.0, 0.0) & (0xFFFFFFFFFFFFFFFF<<shift)
>>> hi = lo + (1<<shift)
>>> db.execute("SELECT * FROM samples WHERE geoint>=? AND geoint<?", (lo, hi))
}}}

With uint64, you can get the ranges by expand_uint64.

{{{
>>> import geohash
>>> ui = geohash.encode_uint64(0,0)
>>> geohash.expand_uint64(ui, 45)
[(4611686018426863616, 4611686018427387904), 
 (7686143364045471744, 7686143364045996032), 
 (7686143364046520320, 7686143364047044608), 
 (10760600709663555584, 10760600709664604160), 
 (13835058055282163712, 13835058055284260864)]
>>> 
>>> conds = []
>>> param = []
>>> for hilo from geohash.expand_uint64(ui, 45):
>>>     if hilo[0]:
>>>         conds.append("geoint>=?")
>>>         param.append(hilo[0])
>>>     
>>>     if hilo[1]:
>>>         conds.append("geoint<?")
>>>         param.append(hilo[1])
>>> 
>>> if conds:
>>>     db.execute("SELECT * FROM samples WHERE " + " AND ".join(conds), param)
>>> else:
>>>     db.execute("SELECT * FROM samples")
}}}
